function scoreGame()

    if not ScoreGameConfirmed then
        ScoreGameConfirmed = true
        -- Absolute value of the offsets in each direction
        -- from the Player's board
        local x_offset = 14
        local y_offset = -0.15
        local z_offset = 9
        createScoringZones(2 * x_offset, 5.1, 2 * z_offset)
        drawScoringZoneBoundaries(x_offset, y_offset, z_offset)
        createGuildMembershipZones()
        createEmployedTranslatorZone()

        broadcastToAll(
            'Read the console message before pressing the '
            .. '"Score Game" button again.',
            log_message_color
        )
        printToAll(
            '\n\nEach Player should ensure that all of the items in their '
            .. 'play area are inside their colored rectangle. Additionally, '
            .. 'make sure that Retired Translators and Translated Scroll '
            .. 'Cards are not stacked (i.e. decks), or they will not '
            .. 'be scored.',
            log_message_color
        )
        return 0
    -- Second time, clean up each Player's area
    else
        for _, player_color in ipairs(getSeatedPlayers()) do
            for _, obj in ipairs(PlayerComponents[player_color].rest_zone.getObjects()) do
                if obj.getGMNotes() == 'Worker' then
                    obj.destruct()
                end
            end

            for _, obj in ipairs(PlayerComponents[player_color].scoring_zone.getObjects()) do
                if obj.getGMNotes() == 'Dice' then

                    if obj.getLock() then
                        obj.setLock(false)
                        local supply_bag = nil
                        if obj.getName() == 'Purple Die' then
                            supply_bag = PurpleDiceBag
                        elseif obj.getName() == 'Orange Die' then
                            supply_bag = OrangeDiceBag
                        elseif obj.getName() == 'Green Die' then
                            supply_bag = GreenDiceBag
                        end

                        supply_bag.putObject(obj)
                    else
                        PlayerComponents[player_color].dice_bag.putObject(obj)
                    end
                end
            end
        end

        -- If the Players are rescoring, move any Influence
        -- Markers from the Dice Sum scoring area
        for _, zone_tbl in ipairs(DiceSumZones) do
            for _, obj in ipairs(zone_tbl.zone.getObjects()) do
                if obj.hasTag('Influence') then
                    local player_color = obj.getGMNotes()
                    if player_color ~= opponent.name then
                        PlayerComponents[
                            player_color
                        ].influence_bag.putObject(obj)
                    else
                        opponent.influence_bag.putObject(obj)
                    end
                end
            end
        end

    end

    function determineEndState()
        --[[
            Determine the ending game state for each Player.

            A Player's ending game state consists of
                * Silver
                * Gold
                * Workers
                * Employed Translators (those still in Rooms on the main board)
                * Translated Scrolls
                * Counts of the number of scrolls translated of a given language
                * Levels on the various Research Tracks
                * Amounts of Dice
                * Membership in the various Guilds of the House of Wisdom

            A Player's end game state is stored in the table PlayerEndState.
            This is indexed by the Player's color, then the category to be
            considered; this will return a table.

        ]]
        for i, player_color in ipairs(getSeatedPlayers()) do
            --[[
                Assume Players have none of the following items to start
                * Silver
                * Gold
                * Workers
                * Employed Translators
                * Retired Translators
                * Translated Scrolls
            ]]
            PlayerEndState[player_color].Silver.num = 0
            PlayerEndState[player_color].Gold.num = 0
            PlayerEndState[player_color].Workers.num = 0
            PlayerEndState[player_color].employed_translators.num = 0
            -- Assume Players have translated no scrolls
            languages = {
                'Chinese',
                'Sanskrit',
                'Greek',
                'Hebrew',
                'Persian',
                'Syriac'
            }
            for _, language in ipairs(languages) do
                PlayerEndState[player_color]['Translated Scrolls'][language] = 0
            end

            for j, obj in ipairs(PlayerComponents[player_color].scoring_zone.getObjects()) do
                if obj.hasTag('Translator') then
                    table.insert(
                        PlayerEndState[player_color].retired_translators,
                        obj
                    )
                elseif obj.getName() == 'Silver' then
                    local silver_total = PlayerEndState[player_color].Silver.num
                    PlayerEndState[player_color].Silver.num = silver_total + 1
                elseif obj.getName() == 'Silver Counter' then
                    local silver_total = PlayerEndState[player_color].Silver.num
                    -- The "count" button is the first button on the counter
                    local val = obj.getButtons()[1].label
                    PlayerEndState[player_color].Silver.num = silver_total + val
                elseif obj.getName() == 'Gold' then
                    local gold_total = PlayerEndState[player_color].Gold.num
                    PlayerEndState[player_color].Gold.num = gold_total + 1
                elseif obj.getName() == 'Gold Counter' then
                    local gold_total = PlayerEndState[player_color].Gold.num
                    -- The "count" button is the first button on the counter
                    local val = obj.getButtons()[1].label
                    PlayerEndState[player_color].Gold.num = gold_total + val
                elseif obj.hasTag('Scroll') then
                    -- Add to the list of scrolls the Player has
                    table.insert(
                        PlayerEndState[player_color].scroll_cards,
                        obj
                    )
                    -- Add 1 to the language total
                    local lang_total = PlayerEndState[player_color][
                        'Translated Scrolls'][ScrollCards[obj.getGUID()
                        ].language
                    ]
                    PlayerEndState[player_color]['Translated Scrolls'][
                        ScrollCards[obj.getGUID()].language
                    ] = lang_total + 1
                elseif obj.getGMNotes() == 'Worker' then
                    local tally = PlayerEndState[player_color].Workers.num
                    PlayerEndState[player_color].Workers.num = tally + 1
                end
            end

            -- Determine the Level of each Research Track
            for track, marker in pairs(PlayerComponents[player_color].research_markers) do
                if marker.getPosition().z >= 6.0 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 7'
                elseif marker.getPosition().z >= 5.1 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 6'
                elseif marker.getPosition().z >= 4.2 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 5'
                elseif marker.getPosition().z >= 3.2 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 4'
                elseif marker.getPosition().z >= 2.3 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 3'
                elseif marker.getPosition().z >= 1.4 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 2'
                elseif marker.getPosition().z >= 0.5 then
                    PlayerEndState[player_color].research_tracks[track] = 'Level 1'
                else
                    PlayerEndState[player_color].research_tracks[track] = 'Level 0'
                end
            end

            -- Determine how many dice a player has
            local types_of_dice = {
                'White Die',
                'Red Die',
                'Blue Die',
                'Yellow Die',
                'Purple Die',
                'Orange Die',
                'Green Die',
            }
            for _, die_type in ipairs(types_of_dice) do
                PlayerEndState[player_color][die_type].num = 0
            end

            for _, obj_tbl in ipairs(PlayerComponents[player_color].dice_bag.getObjects()) do
                local total = PlayerEndState[player_color][obj_tbl.name].num
                PlayerEndState[player_color][obj_tbl.name].num = total + 1
            end

        end

        -- Determine a Player's Guild Membership
        for guild, guild_tbl in pairs(HouseOfWisdom) do
            local guild_membership = {}
            for _, player_color in ipairs(getSeatedPlayers()) do
                guild_membership[player_color] = 0
            end
            for _, obj in pairs(guild_tbl.membership_zone.getObjects()) do
                if obj.hasTag('Influence') then
                    local player_color = obj.getGMNotes()
                    if player_color ~= opponent.name then
                        local tally = guild_membership[player_color]
                        guild_membership[player_color] = tally + 1
                    end
                end
            end

            for _, player_color in ipairs(getSeatedPlayers()) do
                PlayerEndState[player_color]['Guild Membership'][
                    guild
                ] = guild_membership[player_color]
            end
        end

        -- Determine how many Employed Translators a Player has
        for _, obj in ipairs(EmployedTranslatorZone.getObjects()) do
            if obj.hasTag('Influence') then
                local player_color = obj.getGMNotes()
                if player_color ~= opponent.name then
                    PlayerEndState[
                        player_color
                    ].employed_translators.num = PlayerEndState[
                        player_color
                    ].employed_translators.num + 1
                end
            end
        end

    end

    function determineOpponentState()

        opponentDiceSumTrack = {
            Vector(-2.94, 0, 0), -- -6 slot
            Vector(-2.44, 0, 0), -- -5 slot
            Vector(-1.95, 0, 0), -- -4 slot
            Vector(-1.45, 0, 0), -- -3 slot
            Vector(-0.97, 0, 0), -- -2 slot
            Vector(-0.48, 0, 0), -- -1 slot
            Vector(0, 0, 0), -- 0 slot
            Vector(0.51, 0, 0), -- 1 slot
            Vector(0.98, 0, 0), -- 2 slot
            Vector(1.48, 0, 0), -- 3 slot
            Vector(1.97, 0, 0), -- 4 slot
            Vector(2.46, 0, 0), -- 5 slot
            Vector(2.96, 0, 0), -- 6 slot
        }
        OpponentEndState = {
            dice_sum = nil
        }
        for idx, offset in ipairs(opponentDiceSumTrack) do
            if isClose(
                diceSumTracker.getPosition().x,
                (SoloBoard.getPosition() + offset).x
            ) then
                -- Tables start at 1, and we need the start to be -6
                OpponentEndState.dice_sum = idx - 7
                break
            end
        end

    end

    scoring_categories = {
        'dice_sum',
        'retired_translators',
        'guild_control',
        'caliph_cards',
        'research_tracks',
        'scroll_cards',
    }
    PlayerScores = {}
    for i, player_color in ipairs(getSeatedPlayers()) do
        PlayerScores[player_color] = {}
        for j, category in ipairs(scoring_categories) do
            PlayerScores[player_color][category] = {}
            PlayerScores[player_color][category].total = 0
            PlayerScores[player_color][category].itemized = {}
        end

        PlayerScores[player_color].total = 0
    end

    end_game_state = {
        'Silver',
        'Gold',
        'retired_translators',
        'employed_translators',
        'research_tracks',
        'Workers',
        'White Die',
        'Red Die',
        'Blue Die',
        'Yellow Die',
        'Purple Die',
        'Orange Die',
        'Green Die',
        'scroll_cards',
        'Translated Scrolls',
        'Guild Membership',
    }
    PlayerEndState = {}
    for i, player_color in ipairs(getSeatedPlayers()) do
        PlayerEndState[player_color] = {}
        for j, category in ipairs(end_game_state) do
            PlayerEndState[player_color][category] = {}
        end
    end

    if soloMode then
        determineOpponentState()
        OpponentScore = {
            total = 0,
            dice_sum = {
                total = 0,
                itemized = {},
            },
            guild_control = {
                total = 0,
                itemized = {},
            },
            caliph_cards = {
                total = 0,
                itemized = {},
            }
        }
    end

    determineEndState()
    scoreRetiredTranslators()
    scoreGuildControl()
    scoreCaliphCards()
    scoreResearchTracks()
    scoreDiceSum()
    scoreScrollCards()

    local winners = determineWinner()
    printScoreDetails()
    broadcastWinners(winners)

end

function determineWinner()
    --[[
        Tally the Players' totals and determine the game's winner.

        In determining the winner, the tie breakers are considered:
            * First Tie Breaker: Player with the most Employed Translators
            * Second Tie Breaker: Player with the most Workers remaining
            * If still tied, all tied Players share the victory

        Returns
        -------
        table
            An array containing the Player color(s) of the winner(s).

    ]]
    -- Add up the Players' totals
    for _, player_color in ipairs(getSeatedPlayers()) do
        for category, cat_table in pairs(PlayerScores[player_color]) do
            if category ~= 'total' then
                PlayerScores[player_color].total = PlayerScores[
                    player_color].total + cat_table.total
            end
        end
    end
    if soloMode then
        for category, cat_table in pairs(OpponentScore) do
            if category ~= 'total' then
                OpponentScore.total = OpponentScore.total + cat_table.total
            end
        end
    end

    -- Build an integer-indexed table for the Players' scores
    -- that can be sorted
    local sortable_table = {}
    for _, player_color in ipairs(getSeatedPlayers()) do
        table.insert(
            sortable_table,
            {
                player_color = player_color,
                total = PlayerScores[player_color].total,
                employed_translators = PlayerEndState[player_color].employed_translators.num,
                workers = PlayerEndState[player_color].Workers.num,
            }
        )
    end
    if soloMode then
        table.insert(
            sortable_table,
            {
                player_color = 'Opponent',
                total = OpponentScore.total,
                employed_translators = 11, -- so it always wins the tie
                workers = 0,
            }
        )
    end
    sortDescending(sortable_table, {'total', 'employed_translators', 'workers'})

    -- Now we have to deal with ties
    -- First Tie Breaker: Player with the most Employed Translators
    -- Second Tie Breaker: Player with the most Workers remaining
    -- If still tied, all tied Players share the victory
    local winners = {sortable_table[1].player_color}
    for j = 2, # getSeatedPlayers() do
        if sortable_table[j].total == sortable_table[1].total then
            if sortable_table[j].employed_translators == sortable_table[1].employed_translators then
                if sortable_table[j].workers == sortable_table[1].workers then
                    table.insert(winners, sortable_table[j].player_color)
                else
                    break
                end
            else
                break
            end
        else
            break
        end
    end

    return winners

end
